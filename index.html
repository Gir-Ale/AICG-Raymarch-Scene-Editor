<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Ray Marching Scene Editor</title>
    <link rel="icon" href="data:,">
    <script src="https://cdn.tailwindcss.com"></script>
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/codemirror.min.css"
    />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/codemirror.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/addon/mode/simple.min.js"></script>
    <style>
      .cm-s-gruvbox-dark-hard.CodeMirror {
        background-color: #1d2021;
        color: #ebdbb2;
        height: 100%;
        overflow-y: auto;
      }
      .cm-s-gruvbox-dark-hard .CodeMirror-gutters {
        background-color: #1d2021;
        border-right: 1px solid #3c3836;
      }
      .cm-s-gruvbox-dark-hard .CodeMirror-guttermarker,
      .cm-s-gruvbox-dark-hard .CodeMirror-guttermarker-subtle,
      .cm-s-gruvbox-dark-hard .CodeMirror-linenumber {
        color: #7c6f64;
      }
      .cm-s-gruvbox-dark-hard .CodeMirror-cursor {
        border-left: 1px solid #ebdbb2;
      }
      .cm-s-gruvbox-dark-hard .CodeMirror-activeline-background {
        background-color: #3c3836;
      }
      .cm-s-gruvbox-dark-hard .CodeMirror-selected {
        background-color: #504945;
      }
      .cm-s-gruvbox-dark-hard span.cm-comment {
        color: #928374;
      }
      .cm-s-gruvbox-dark-hard span.cm-keyword {
        color: #fb4934;
      }
      .cm-s-gruvbox-dark-hard span.cm-operator {
        color: #ebdbb2;
      }
      .cm-s-gruvbox-dark-hard span.cm-punctuation {
        color: #a89984;
      }
      .cm-s-gruvbox-dark-hard span.cm-variable {
        color: #83a598;
      }
      .cm-s-gruvbox-dark-hard span.cm-type {
        color: #fabd2f;
      }
      .cm-s-gruvbox-dark-hard span.cm-def {
        color: #8ec07c;
      }
      .cm-s-gruvbox-dark-hard span.cm-attribute {
        color: #fe8019;
      }
      .cm-s-gruvbox-dark-hard span.cm-builtin {
        color: #fe8019;
      }
      .cm-s-gruvbox-dark-hard span.cm-string {
        color: #b8bb26;
      }
      .cm-s-gruvbox-dark-hard span.cm-number {
        color: #d3869b;
      }
      .cm-s-gruvbox-dark-hard span.cm-error {
        color: #ebdbb2;
        background-color: #fb4934;
      }
      .cm-s-gruvbox-dark-hard .CodeMirror-matchingbracket {
        text-decoration: underline;
        color: #ebdbb2 !important;
      }
      /* Ensure CodeMirror scroll container works properly */
      .CodeMirror-scroll {
        height: 100%;
        overflow-y: auto !important;
        overflow-x: auto !important;
      }
      /* Editor container should fill available space */
      #code-editor-container {
        height: 100%;
        display: flex;
        flex-direction: column;
      }
      #code-editor-container .CodeMirror {
        flex: 1;
        min-height: 0;
      }
    </style>
  </head>
  <body class="font-mono bg-gray-900 text-white overflow-hidden">
    <div
      id="container"
      class="flex w-screen h-screen portrait:flex-col landscape:flex-row"
    >
      <div
        id="canvas-container"
        class="relative flex items-center justify-center bg-black portrait:w-full portrait:h-1/2 landscape:w-1/2 landscape:h-full"
      >
        <canvas id="canvas" class="block"></canvas>
        <div
          id="error-message"
          class="absolute bottom-2.5 left-2.5 right-2.5 text-red-500 text-xs bg-black/80 p-1.5 rounded hidden max-h-24 overflow-y-auto z-10"
        ></div>
        <button
          id="fullscreen-btn"
          class="absolute bottom-2.5 right-2.5 p-2 bg-black/60 hover:bg-black/80 text-white rounded transition-all z-20"
          title="Toggle Fullscreen (F)"
        >
          <svg
            id="fullscreen-enter-icon"
            width="20"
            height="20"
            viewBox="0 0 24 24"
            fill="none"
            stroke="currentColor"
            stroke-width="2"
          >
            <path
              d="M8 3H5a2 2 0 0 0-2 2v3m18 0V5a2 2 0 0 0-2-2h-3m0 18h3a2 2 0 0 0 2-2v-3M3 16v3a2 2 0 0 0 2 2h3"
            />
          </svg>
          <svg
            id="fullscreen-exit-icon"
            width="20"
            height="20"
            viewBox="0 0 24 24"
            fill="none"
            stroke="currentColor"
            stroke-width="2"
            class="hidden"
          >
            <path
              d="M8 3v3a2 2 0 0 1-2 2H3m18 0h-3a2 2 0 0 1-2-2V3m0 18v-3a2 2 0 0 1 2-2h3M3 16h3a2 2 0 0 1 2 2v3"
            />
          </svg>
        </button>
      </div>

      <div
        id="editor-container"
        class="flex flex-col bg-gray-800 portrait:w-full portrait:h-1/2 landscape:w-1/2 landscape:h-full"
      >
        <div
          class="p-2.5 font-bold flex flex-col gap-2"
          style="
            background: #1d2021;
            color: #ebdbb2;
            border-bottom: 1px solid #3c3836;
          "
        >
          <div class="flex items-center justify-between gap-2">
            <div class="flex items-center gap-2">
              <svg
                width="20"
                height="20"
                viewBox="0 0 24 24"
                fill="none"
                stroke="currentColor"
                stroke-width="2"
              >
                <path d="M12 2L2 7L12 12L22 7L12 2Z" />
                <path d="M2 17L12 22L22 17" />
                <path d="M2 12L12 17L22 12" />
              </svg>
              <span>[WGSL] Fragment Shader Editor & Shape Builder</span>
            </div>
          </div>

          <div class="w-full h-px" style="background-color: #665c54; opacity: 0.5"></div>

          <div class="flex items-center justify-between gap-3">
            <div class="flex flex-wrap items-center gap-3">
              <span class="text-sm font-normal whitespace-nowrap">
                <span style="opacity: 0.5">FPS:</span>
                <span id="fps">0</span>
                <span style="opacity: 0.5; margin-left: 8px">Frame:</span>
                <span id="frame-time">0ms</span>
              </span>
              <span class="text-sm font-normal whitespace-nowrap">
                <span style="opacity: 0.5">Compile:</span>
                <span id="compile-time"></span>
              </span>
            </div>
            <button
              id="compile-btn"
              class="px-3 py-1 text-sm rounded bg-green-700 hover:bg-green-600 transition-colors whitespace-nowrap"
              title="Compile (Ctrl/Cmd+Enter)"
            >
              Compile
            </button>
          </div>
        </div>

        <div class="flex flex-1 overflow-hidden">
          <div id="code-editor-container" class="flex-1 overflow-hidden">
            <textarea id="code-editor"></textarea>
          </div>

          <div
            id="uniforms-panel"
            class="flex transition-all duration-300"
            style="width: 250px"
          >
            <div
              id="panel-toggle"
              class="w-6 cursor-pointer hover:opacity-80 flex items-center justify-center"
              style="background: #3c3836; color: #a89984"
            >
              <span id="toggle-arrow">▶</span>
            </div>

            <div
              id="panel-content"
              class="flex-1 flex flex-col overflow-hidden"
              style="background: #1d2021"
            >
              <div
                class="p-2 font-bold flex flex-col gap-3"
                style="color: #ebdbb2; border-bottom: 1px solid #3c3836"
              >
                <div class="flex items-center gap-2">
                  <svg
                    width="16"
                    height="16"
                    viewBox="0 0 24 24"
                    fill="none"
                    stroke="currentColor"
                    stroke-width="2"
                  >
                    <rect x="3" y="3" width="7" height="7" />
                    <rect x="14" y="3" width="7" height="7" />
                    <rect x="14" y="14" width="7" height="7" />
                    <rect x="3" y="14" width="7" height="7" />
                  </svg>

                  <select
                    id="shape-select"
                    class="flex-1 bg-gray-700 text-white rounded-lg px-2 py-1"
                  >
                    <option value="cube">Cube</option>
                    <option value="sphere">Sphere</option>
                    <option value="torus">Torus</option>
                    <option value="cylinder">Cylinder</option>
                    <option value="pyramid">Pyramid</option>
                    <option value="cone">Cone</option>
                  </select>

                  <button
                    id="build-btn"
                    class="bg-blue-600 hover:bg-blue-500 rounded-lg px-3 py-1 text-sm font-semibold"
                  >
                    Build
                  </button>
                </div>

                <!-- Shape List -->
                <div>
                  <label class="block text-sm font-semibold mb-1">Shapes List</label>
                  <ul
                    id="shape-list"
                    class="bg-gray-700 rounded-lg p-2 max-h-28 overflow-y-auto text-sm space-y-1"
                  ></ul>
                </div>
                <button
                  id="remove-btn"
                  class="bg-red-600 hover:bg-red-500 rounded-lg px-3 py-1 text-sm font-semibold"
                  >Remove
                </button>
                <!-- Shape Properties -->
                <div id="shape-properties" class="mt-3 border-t border-gray-600 pt-3">
                  <h3 class="text-sm font-semibold mb-2">Properties</h3>
                  <div class="grid grid-cols-2 gap-2">

                    <label class="text-xs">X</label>
                    <input id="prop-x" type="range" class="bg-gray-700 rounded px-2 py-1 text-xs" min="-5" max="5" step="0.05" value="0" />
                    <label class="text-xs">Y</label>
                    <input id="prop-y" type="range" class="bg-gray-700 rounded px-2 py-1 text-xs" min="-5" max="5" step="0.05" value="0" />
                    <label class="text-xs">Z</label>
                    <input id="prop-z" type="range" class="bg-gray-700 rounded px-2 py-1 text-xs" min="-5" max="5" step="0.05" value="0" />

                    <label class="text-xs">SIZE X</label>
                    <input id="prop-sizeX" type="range" class="bg-gray-700 rounded px-2 py-1 text-xs" min="0.1" max="2.5" step="0.05" value="0.5" />
                    <label class="text-xs">SIZE Y</label>
                    <input id="prop-sizeY" type="range" class="bg-gray-700 rounded px-2 py-1 text-xs" min="0.1" max="2.5" step="0.05" value="0.5" />
                    <label class="text-xs">SIZE Z</label>
                    <input id="prop-sizeZ" type="range" class="bg-gray-700 rounded px-2 py-1 text-xs" min="0.1" max="2.5" step="0.05" value="0.5" />

                    <label class="text-xs">ANGLE X</label>
                    <input id="prop-rotX" type="range" class="bg-gray-700 rounded px-2 py-1 text-xs" min="0" max="6.28" step="0.05" value="0" />
                    <label class="text-xs">ANGLE Y</label>
                    <input id="prop-rotY" type="range" class="bg-gray-700 rounded px-2 py-1 text-xs" min="0" max="6.28" step="0.05" value="0" />
                    <label class="text-xs">ANGLE Z</label>
                    <input id="prop-rotZ" type="range" class="bg-gray-700 rounded px-2 py-1 text-xs" min="0" max="6.28" step="0.05" value="0" />

                    <label class="text-xs col-span-1">Material</label>
                    <input
                      id="prop-material"
                      type="color"
                      class="bg-gray-700 rounded px-2 py-1 text-xs col-span-1"
                      value="#ff0000"
                    />
                  </div>
                </div>
              </div>

              <div class="flex-1 overflow-y-auto overflow-x-hidden p-3">
                <table class="w-full text-sm" style="color: #ebdbb2">
                  <tbody id="uniforms-table"></tbody>
                </table>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
    <script>
      let fallbackShader = `// Fragment shader - runs once per pixel
@fragment
fn fs_main(@builtin(position) fragCoord: vec4<f32>) -> @location(0) vec4<f32> {
    // Simple gradient as fallback
    let uv = fragCoord.xy / uniforms.resolution;
    return vec4<f32>(uv, 0.5, 1.0);
}`;

      CodeMirror.defineSimpleMode("wgsl", {
              start: [
                { regex: /\b(fn|let|var|const|if|else|for|while|loop|return|break|continue|discard|switch|case|default|struct|type|alias)\b/, token: "keyword" },
                { regex: /\b(bool|i32|u32|f32|f16|vec2|vec3|vec4|mat2x2|mat3x3|mat4x4|array|sampler|texture_2d|texture_3d)\b/, token: "type" },
                { regex: /\b(vec2|vec3|vec4|mat2x2|mat3x3|mat4x4|array)<[^>]+>/, token: "type" },
                { regex: /\b(abs|acos|all|any|asin|atan|atan2|ceil|clamp|cos|cosh|cross|degrees|determinant|distance|dot|exp|exp2|faceforward|floor|fma|fract|frexp|inversesqrt|ldexp|length|log|log2|max|min|mix|modf|normalize|pow|radians|reflect|refract|round|sign|sin|sinh|smoothstep|sqrt|step|tan|tanh|transpose|trunc)\b/, token: "builtin" },
                { regex: /@(vertex|fragment|compute|builtin|location|binding|group|stage|workgroup_size|interpolate|invariant)/, token: "attribute" },
                { regex: /\b\d+\.?\d*[fu]?\b|0x[0-9a-fA-F]+[ul]?/, token: "number" },
                { regex: /\/\/.*/, token: "comment" },
                { regex: /\/\*/, token: "comment", next: "comment" },
                { regex: /[+\-*/%=<>!&|^~?:]/, token: "operator" },
                { regex: /[{}()\[\];,\.]/, token: "punctuation" },
              ],
              comment: [
                { regex: /.*?\*\//, token: "comment", next: "start" },
                { regex: /.*/, token: "comment" },
              ],
            }); // prettier-ignore

      const editor = CodeMirror.fromTextArea(
        document.getElementById("code-editor"),
        {
          mode: "wgsl",
          theme: "gruvbox-dark-hard",
          lineNumbers: true,
          lineWrapping: true,
          value: fallbackShader,
          tabSize: 2,
          indentUnit: 2,
          viewportMargin: Infinity,
          scrollbarStyle: "native",
        },
      );
      editor.setValue(fallbackShader);

      let device;
      let context;
      let pipeline;
      let uniformBuffer;
      let bindGroup;
      let startTime = performance.now();
      let lastFrameTime = startTime;
      let frameCount = 0;
      let lastFpsUpdate = startTime;
      let mouseX = 0;
      let mouseY = 0;
      let mouseDown = false;
      let isPanelOpen = true;
      let isFullscreen = false;
      let frequency = 16; // the maximum frequency at wich the object buffer is updated in Hz
      let lastObjectUpdate = 0;

      let objectBuffer;  
      let shapesDirty = true;

      const $ = (id) => document.getElementById(id);
      const canvas = $("canvas");
      const errorMsg = $("error-message");
      const compileBtn = $("compile-btn");
      const fullscreenBtn = $("fullscreen-btn");
      const fullscreenEnterIcon = $("fullscreen-enter-icon");
      const fullscreenExitIcon = $("fullscreen-exit-icon");
      const canvasContainer = $("canvas-container");
      const editorContainer = $("editor-container");
      const shaderSelector = $("shader-selector");

      const MAX_OBJECTS = 20;
      // Each object uses 20 floats: 4 for objType (u32 + 3 padding), 4 for position (vec3 + 1 padding), 4 for scale (vec3 + 1 padding), 4 for rotation (vec3 + 1 padding), 4 for material (vec3 + 1 padding)
      const objectBufferSize = (MAX_OBJECTS * 20); // 20 floats per object: struct alignment for GPU storage buffer

      const uniforms = {
        resolution: {
          label: "resolution",
          initial: "0 × 0",
          update: (w, h) => `${w} × ${h}`,
        },
        time: {
          label: "time",
          initial: "0.00s",
          update: (t) => `${t.toFixed(2)}s`,
        },
        deltaTime: {
          label: "deltaTime",
          initial: "0.00ms",
          update: (dt) => `${(dt * 1000).toFixed(2)}ms`,
        },
        mousexy: {
          label: "mouse.xy",
          initial: "0, 0",
          update: (x, y) => `${Math.round(x)}, ${Math.round(y)}`,
        },
        mousez: {
          label: "mouse.z",
          initial:
            '<span class="inline-block w-2 h-2 rounded-full" id="mouse-ind" style="background:#928374"></span>',
          update: (down) => {
            $("mouse-ind").style.background = down ? "#b8bb26" : "#928374";
            return null;
          },
        },
        frame: {
          label: "frame",
          initial: "0",
          update: (f) => f.toString(),
        },
      };

      $("uniforms-table").innerHTML = Object.entries(uniforms)
        .map(
          ([key, u]) =>
            `<tr class="border-b" style="border-color:#3c3836"><td class="py-1.5 font-semibold" style="color:#fe8019">${u.label}</td><td class="py-1.5 text-right font-mono" id="u-${key}">${u.initial}</td></tr>`,
        )
        .join("");

      const myScene = {
        numObjects: 0,
        objects: new Array(MAX_OBJECTS).fill(null).map(() => null),
      };

      canvas.addEventListener("mousemove", (e) => {
        const rect = canvas.getBoundingClientRect();
        const dpr = devicePixelRatio || 1;
        [mouseX, mouseY] = [
          (e.clientX - rect.left) * dpr,
          (e.clientY - rect.top) * dpr,
        ];
      });
      canvas.addEventListener("mousedown", () => (mouseDown = true));
      canvas.addEventListener("mouseup", () => (mouseDown = false));
      canvas.addEventListener("mouseleave", () => (mouseDown = false));

      $("panel-toggle").onclick = () => {
        isPanelOpen = !isPanelOpen;
        $("uniforms-panel").style.width = isPanelOpen ? "250px" : "24px";
        $("panel-content").style.display = isPanelOpen ? "flex" : "none";
        $("toggle-arrow").textContent = isPanelOpen ? "◀" : "▶";
      };

      const vertexShader = `@vertex
fn vs_main(@builtin(vertex_index) vertexIndex: u32) -> @builtin(position) vec4<f32> {
  var pos = array<vec2<f32>, 3>(vec2<f32>(-1.0, -1.0), vec2<f32>(3.0, -1.0), vec2<f32>(-1.0, 3.0));
  return vec4<f32>(pos[vertexIndex], 0.0, 1.0);
}`;

      const uniformsStruct = `struct Uniforms {
  resolution: vec2<f32>, time: f32, deltaTime: f32, mouse: vec4<f32>, frame: u32,
  _padding: u32, _padding2: u32, _padding3: u32,
}
@group(0) @binding(0) var<uniform> uniforms: Uniforms;`;

      async function initWebGPU() {
        if (!navigator.gpu)
          return ((errorMsg.textContent = "WebGPU not supported"), false);
        const adapter = await navigator.gpu.requestAdapter();
        if (!adapter) return ((errorMsg.textContent = "No GPU adapter"), false);
        device = await adapter.requestDevice();
        context = canvas.getContext("webgpu");
        const format = navigator.gpu.getPreferredCanvasFormat();
        context.configure({ device, format });
        uniformBuffer = device.createBuffer({
          size: 64,
          usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
        });
        objectBuffer = device.createBuffer({
            size: (objectBufferSize * 4),
            usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,
        });

        await compileShader(fallbackShader);
        return true;
      }

      async function compileShader(fragmentCode) {
        const start = performance.now();
        try {
          errorMsg.classList.add("hidden");
          const code = vertexShader + "\n" + uniformsStruct + "\n" + fragmentCode; // prettier-ignore
          const shaderModule = device.createShaderModule({ code });
          const info = await shaderModule.getCompilationInfo();
          const lineOffset = (vertexShader + "\n" + uniformsStruct).split("\n").length; // prettier-ignore
          const errors = info.messages
            .filter((m) => m.type === "error")
            .map((m) => {
              const fragmentLine = m.lineNum - lineOffset;
              return fragmentLine > 0
                ? `Line ${fragmentLine}: ${m.message}`
                : `Line ${m.lineNum}: ${m.message}`;
            })
            .join("\n");
          if (errors)
            return (
              (errorMsg.textContent = "Shader error:\n" + errors),
              errorMsg.classList.remove("hidden")
            );

          const format = navigator.gpu.getPreferredCanvasFormat();
          const bindGroupLayout = device.createBindGroupLayout({
            entries: [
              {
                binding: 0,
                visibility: GPUShaderStage.FRAGMENT,
                buffer: { type: "uniform" },
              },
              {
                binding: 1,
                visibility: GPUShaderStage.FRAGMENT,
                buffer: { type: "read-only-storage" },
              },
            ],
          });
          pipeline = device.createRenderPipeline({
            layout: device.createPipelineLayout({
              bindGroupLayouts: [bindGroupLayout],
            }),
            vertex: { module: shaderModule, entryPoint: "vs_main" },
            fragment: {
              module: shaderModule,
              entryPoint: "fs_main",
              targets: [{ format }],
            },
            primitive: { topology: "triangle-list" },
          });
          bindGroup = device.createBindGroup({
              layout: pipeline.getBindGroupLayout(0),
              entries: [
                { binding: 0, resource: { buffer: uniformBuffer }},
                { binding: 1, resource: { buffer: objectBuffer }},
              ],
          });
          $("compile-time").textContent = `${(performance.now() - start).toFixed(2)}ms`; // prettier-ignore
        } catch (e) {
          errorMsg.textContent = "Compile error: " + e.message;
          errorMsg.classList.remove("hidden");
        }
      }

      function shapeTypeToInt(type) {
        switch(type) {
          case "cube":   return 1;
          case "sphere": return 2;
          case "torus":  return 3;
          case "cylinder":  return 4;
          case "pyramid":  return 5;
          case "cone":     return 6;
          default:       return 0; 
        }
      }

      function materialColorToRGB(color) {
        const r = parseInt(color.slice(1, 3), 16) / 255;
        const g = parseInt(color.slice(3, 5), 16) / 255;
        const b = parseInt(color.slice(5, 7), 16) / 255;
        return [r, g, b];
      }

      function updateMySceneFromShapes() {
        myScene.numObjects = shapes.length;
        for (let i = 0; i < MAX_OBJECTS; i++) {
          if (i < shapes.length) {
            const s = shapes[i];
            myScene.objects[i] = {
              objType: shapeTypeToInt(s.type),
              position: [s.posX, s.posY, s.posZ],
              scale: [s.sizeX, s.sizeY, s.sizeZ],
              rotation: [s.rotX, s.rotY, s.rotZ],
              materialRGB: materialColorToRGB(s.material),
            };
          } else {
            // Reset unused slots
            myScene.objects[i] = { objType: 0, position: [0, 0, 0], scale: [1, 1, 1], rotation: [0, 0, 0], materialRGB: [0, 0, 0] };
          }
        }
      }

      const objectBufferData = new Float32Array(objectBufferSize)

      function fillObjectBufferOnce() {
          // Clear buffer
          objectBufferData.fill(0);

          // Loop over objects
          for (let i = 0; i < MAX_OBJECTS; i++) {
            if (i < myScene.numObjects) {
              const idx =  i * 20; // 20 floats per object
              const s = myScene.objects[i];

              // === Object struct alignment ===
              // u32 objType + 3x padding
              objectBufferData[idx + 0] = s.objType;
              objectBufferData[idx + 1] = 0; // padding
              objectBufferData[idx + 2] = 0; // padding
              objectBufferData[idx + 3] = 0; // padding

              // vec3<f32> position + 1 float padding
              objectBufferData[idx + 4] = s.position[0];
              objectBufferData[idx + 5] = s.position[1];
              objectBufferData[idx + 6] = s.position[2];
              objectBufferData[idx + 7] = 0; // padding

              // vec3<f32> scale + 1 float padding
              objectBufferData[idx + 8]  = s.scale[0];
              objectBufferData[idx + 9]  = s.scale[1];
              objectBufferData[idx + 10] = s.scale[2];
              objectBufferData[idx + 11] = 0; // padding

              // vec3<f32> rotation +  1 float padding
              objectBufferData[idx + 12] = s.rotation[0];
              objectBufferData[idx + 13] = s.rotation[1];
              objectBufferData[idx + 14] = s.rotation[2];
              objectBufferData[idx + 15] = 0; // padding

              // vec3<f32> materialRGB + 1 float padding
              objectBufferData[idx + 16] = s.materialRGB[0];
              objectBufferData[idx + 17] = s.materialRGB[1]; 
              objectBufferData[idx + 18] = s.materialRGB[2];
              objectBufferData[idx + 19] = 0; // padding
            }
          }

          // Upload to GPU
          device.queue.writeBuffer(objectBuffer, 0, objectBufferData);
      }


      // Preallocate uniform data buffer
      const uniformData = new Float32Array(12);

      function render() {
        if (!pipeline) return;
        const currentTime = performance.now();
        const deltaTime = (currentTime - lastFrameTime) / 1000;
        const elapsedTime = (currentTime - startTime) / 1000;
        uniformData[0] = canvas.width;
        uniformData[1] = canvas.height;
        uniformData[2] = elapsedTime;
        uniformData[3] = deltaTime;
        uniformData[4] = mouseX;
        uniformData[5] = mouseY;
        uniformData[6] = mouseDown ? 1 : 0;
        uniformData[7] = 0;
        uniformData[8] = frameCount;
        uniformData[9] = 0;
        uniformData[10] = 0;
        uniformData[11] = 0;
        device.queue.writeBuffer(uniformBuffer, 0, uniformData);

        if (shapesDirty && currentTime - lastObjectUpdate >= (1000 / frequency)) {
          updateMySceneFromShapes();
          fillObjectBufferOnce();
          shapesDirty = false;
          lastObjectUpdate = currentTime;
        }

        const val = uniforms.resolution.update(canvas.width, canvas.height);

        if (val) $("u-resolution").textContent = val;
        $("u-time").textContent = uniforms.time.update(elapsedTime);
        $("u-deltaTime").textContent = uniforms.deltaTime.update(deltaTime);
        $("u-mousexy").textContent = uniforms.mousexy.update(mouseX, mouseY);
        $("u-frame").textContent = uniforms.frame.update(frameCount);

        uniforms.mousez.update(mouseDown);

        lastFrameTime = currentTime;

        const encoder = device.createCommandEncoder();
        const pass = encoder.beginRenderPass({
          colorAttachments: [
            {
              view: context.getCurrentTexture().createView(),
              loadOp: "clear",
              clearValue: { r: 0, g: 0, b: 0, a: 1 },
              storeOp: "store",
            },
          ],
        });
        pass.setPipeline(pipeline);
        pass.setBindGroup(0, bindGroup);
        pass.draw(3);
        pass.end();
        device.queue.submit([encoder.finish()]);

        if (++frameCount && currentTime - lastFpsUpdate > 100) {
          const fps = Math.round(frameCount / ((currentTime - lastFpsUpdate) / 1_000)); // prettier-ignore
          $("fps").textContent = fps;
          $("frame-time").textContent = `${((currentTime - lastFpsUpdate) / frameCount).toFixed(1)}ms`; // prettier-ignore
          frameCount = 0;
          lastFpsUpdate = currentTime;
        }
        requestAnimationFrame(render);
      }


      function resizeCanvas() {
        const container = $("canvas-container");
        const dpr = devicePixelRatio || 1;
        canvas.width = container.clientWidth * dpr;
        canvas.height = container.clientHeight * dpr;
        canvas.style.width = container.clientWidth + "px";
        canvas.style.height = container.clientHeight + "px";
      }

      compileBtn.onclick = () => compileShader(editor.getValue());

      function toggleFullscreen() {
        if (
          !document.fullscreenElement &&
          !document.webkitFullscreenElement &&
          !document.mozFullScreenElement &&
          !document.msFullscreenElement
        ) {
          const elem = canvasContainer;
          if (elem.requestFullscreen) {
            elem.requestFullscreen();
          } else if (elem.webkitRequestFullscreen) {
            elem.webkitRequestFullscreen();
          } else if (elem.mozRequestFullScreen) {
            elem.mozRequestFullScreen();
          } else if (elem.msRequestFullscreen) {
            elem.msRequestFullscreen();
          }
        } else {
          if (document.exitFullscreen) {
            document.exitFullscreen();
          } else if (document.webkitExitFullscreen) {
            document.webkitExitFullscreen();
          } else if (document.mozCancelFullScreen) {
            document.mozCancelFullScreen();
          } else if (document.msExitFullscreen) {
            document.msExitFullscreen();
          }
        }
      }

      function updateFullscreenUI() {
        const fullscreenElement =
          document.fullscreenElement ||
          document.webkitFullscreenElement ||
          document.mozFullScreenElement ||
          document.msFullscreenElement;

        isFullscreen = !!fullscreenElement;
        if (isFullscreen) {
          fullscreenEnterIcon.classList.add("hidden");
          fullscreenExitIcon.classList.remove("hidden");
          editorContainer.style.display = "none";
          canvasContainer.classList.remove("landscape:w-1/2", "portrait:h-1/2");
          canvasContainer.classList.add("w-full", "h-full");
        } else {
          fullscreenEnterIcon.classList.remove("hidden");
          fullscreenExitIcon.classList.add("hidden");
          editorContainer.style.display = "";
          canvasContainer.classList.remove("w-full", "h-full");
          canvasContainer.classList.add("landscape:w-1/2", "portrait:h-1/2");
        }

        setTimeout(resizeCanvas, 50);
      }

      fullscreenBtn.onclick = toggleFullscreen;
      document.addEventListener("fullscreenchange", updateFullscreenUI);
      document.addEventListener("webkitfullscreenchange", updateFullscreenUI);
      document.addEventListener("mozfullscreenchange", updateFullscreenUI);
      document.addEventListener("MSFullscreenChange", updateFullscreenUI);

      document.addEventListener("keydown", (e) => {
        if ((e.ctrlKey || e.metaKey) && e.key === "Enter") {
          e.preventDefault();
          compileShader(editor.getValue());
        }
        if (
          e.key === "f" &&
          !e.ctrlKey &&
          !e.metaKey &&
          !e.altKey &&
          !e.shiftKey
        ) {
          if (document.activeElement !== editor.getInputField()) {
            e.preventDefault();
            toggleFullscreen();
          }
        }
      });
      window.addEventListener("resize", resizeCanvas);

      // Load shaders from files
      async function loadShaders() {
        let loadedCount = 0;
        let manifest = null;
        try {
          const response = await fetch(`./raymarch_editor.wgsl`);
          if (response.ok) {
            const content = await response.text();
            fallbackShader = content;
            editor.setValue(fallbackShader);
            compileShader(fallbackShader);
          }
        } catch (err) {
          console.error(`Failed to load shader ${shaderInfo.file}:`, err);
        }
      }

      // Shape Builder Logic
      const buildBtn = document.getElementById("build-btn");
      const removeBtn = document.getElementById("remove-btn");
      const shapeSelect = document.getElementById("shape-select");
      const shapeList = document.getElementById("shape-list");
      const propInputs = {
        sizeX: document.getElementById("prop-sizeX"),
        sizeY: document.getElementById("prop-sizeY"),
        sizeZ: document.getElementById("prop-sizeZ"),
        posX: document.getElementById("prop-x"),
        posY: document.getElementById("prop-y"),
        posZ: document.getElementById("prop-z"),
        rotX: document.getElementById("prop-rotX"),
        rotY: document.getElementById("prop-rotY"),
        rotZ: document.getElementById("prop-rotZ"),
        mat: document.getElementById("prop-material"),
      };
      

      let shapes = [];
      let selectedIndex = -1;

      function updateShapeList() {
        shapeList.innerHTML = "";
        for (let i = shapes.length - 1; i >= 0; i--) {
            const shape = shapes[i];
            const li = document.createElement("li");
            li.textContent = `${i + 1}. ${shape.type}`;
            li.className =
            "cursor-pointer rounded px-2 py-1 hover:bg-gray-600 " +
            (i === selectedIndex ? "bg-gray-600" : "");
            li.onclick = () => selectShape(i);
            shapeList.appendChild(li);
        }
      }

      function selectShape(index) {
          selectedIndex = index;
          const shape = shapes[index];
          if (!shape) return;

          updateShapeList();
      }

      removeBtn.addEventListener("click", () => {
        if (selectedIndex < 0 || !shapes[selectedIndex]) return;

        const removedShape = shapes[selectedIndex];

        removedShape.type = "";
        removedShape.objType = 0;

        if (removedShape.originalType) {
          shapeSelect.value = removedShape.originalType;
        } else {
          shapeSelect.value = removedShape.type || "cube";
        }

        shapes.splice(selectedIndex, 1);
        selectedIndex = -1;

        updateShapeList();
        
        shapesDirty = true;
      });

      function buildShape() {
        const type = shapeSelect.value;
        const newShape = {
          type,
          sizeX: (parseFloat(propInputs.sizeX.value)|| 1),
          sizeY: (parseFloat(propInputs.sizeY.value)|| 1),
          sizeZ: (parseFloat(propInputs.sizeZ.value)|| 1),
          posX: (parseFloat(propInputs.posX.value)|| 0),
          posY: (parseFloat(propInputs.posY.value)|| 0),
          posZ: (parseFloat(propInputs.posZ.value)|| 0),
          rotX: (parseFloat(propInputs.rotX.value) || 0),
          rotY: (parseFloat(propInputs.rotY.value) || 0),
          rotZ: (parseFloat(propInputs.rotZ.value) || 0),
          material: (propInputs.mat.value || "#ff0000"),
        };
        if (shapes.length < MAX_OBJECTS) {
          shapes.push(newShape);
          updateShapeList();
          selectShape(shapes.length - 1);
          shapesDirty = true;
        }
      }

      for (const key in propInputs) {
        const handler = () => {
          if (selectedIndex < 0) return;
          const shape = shapes[selectedIndex];

          if (["sizeX","sizeY","sizeZ","posX","posY","posZ","rotX","rotY","rotZ"].includes(key)) {
            shape[key] = parseFloat(propInputs[key].value) || 0;
          } else {
            shape[key] = propInputs[key].value;
          }
          shape.material = propInputs.mat.value || "#ff0000"; //always update material
          shapesDirty = true;
        };

        propInputs[key].addEventListener("input", handler);
        propInputs[key].addEventListener("change", handler);
      }

      buildBtn.addEventListener("click", buildShape);

      //Override selectShape to populate the editor controls with the selected object's values 
      window.selectShape = function (index) {
        selectedIndex = index;
        const shape = shapes[index];
        if (!shape) {
          selectedIndex = -1;
          // Reset inputs to defaults when no shape
          propInputs.sizeX.value = 1;
          propInputs.sizeY.value = 1;
          propInputs.sizeZ.value = 1;
          propInputs.posX.value = 0;
          propInputs.posY.value = 0;
          propInputs.posZ.value = 0;
          propInputs.rotX.value = 0;
          propInputs.rotY.value = 0;
          propInputs.rotZ.value = 0;
          propInputs.mat.value = "#ff0000";
          updateShapeList();
          return;
        }

        // Populate inputs with the shape's values
        propInputs.sizeX.value = shape.sizeX || 1;
        propInputs.sizeY.value = shape.sizeY || 1;
        propInputs.sizeZ.value = shape.sizeZ || 1;

        propInputs.posX.value = shape.posX || 0;
        propInputs.posY.value = shape.posY || 0;
        propInputs.posZ.value = shape.posZ || 0;

        propInputs.rotX.value = shape.rotX || 0;
        propInputs.rotY.value = shape.rotY || 0;
        propInputs.rotZ.value = shape.rotZ || 0;

        propInputs.mat.value = shape.material || "#ff0000";

        updateShapeList();

        // Scroll the selected list item into view (list is rendered in reverse)
        const liIndex = shapes.length - 1 - index;
        const li = shapeList.children[liIndex];
        if (li) li.scrollIntoView({ block: "nearest" });
      };

      // Main initialization
      const main = async () => {
        await loadShaders();
        resizeCanvas();
        if (await initWebGPU()) render();
      };
      main();
    </script>
  </body>
</html>

